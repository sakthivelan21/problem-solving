# Java Notes 

## This repo contains source code of java concepts and oops.


### Problem solving in java 

+ [Coding Problems in java](https://github.com/sakthivelan21/problem-solving/blob/main/coding-problems/problems-in-java)

+ [Console Based Projects in java](https://github.com/sakthivelan21/problem-solving/blob/main/coding-problems/Java-notes/Console-based-projects)

### Codes in this repo

+ Basic Hello World 

	+ [Simple Hello World Program](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Basics/HelloWorld.java)

	+ [Assertion Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Basics/AssertionExample.java)


+ Command Line Arguments

	+ [Command Line Arguments Program](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Basics/CommandLineArguments.java)

	+ [Command Line Arguments sum Program](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Basics/CommandLineArgumentsSum.java)

+ Sorting Alogrithms

	+ [Sorting Alogrithms ](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/SortingAlgorithms/SortData.java)


+ Methods 

	+ [Final Methods](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Basics/FinalMethods.java)

	+ [Method Arguments](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Basics/MethodArguments.java)

	+ [To String Override](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Basics/ToStringOverride.java)

	+ [Arrow Functions](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Basics/ArrowFunctions.java)



+ Searching Algorithms

	+ [Linear Search](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Searching-Algorithms/LinearSearch.java)

	+ [Binary Search](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Searching-Algorithms/BinarySearch.java)

	+ [Recursive Binary Search](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Searching-Algorithms/RecursiveBinarySearch.java)

+ String
	
	+ [String Manipulation in java](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Strings/StringManipulation.java)

	+ [ComapareTo Example in java](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Strings/CompareToExample.java)

	+ [String Buffer Example in java](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Strings/OtherStringClassManipulation.java)




+ Arrays

	+ [For Each with Array Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/ForEachLoop.java)

	+ [Arrays class In Built Methods Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/ArrayMethodsExample.java)

	+ [Transpose of Matrix](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/TransposeOfMatrix.java)

	+ [Matrix Multiplication](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/MatrixMultiplication.java)

	

	+ [Dynamic Array Size change]((https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/DynamicArraySizeChange.java))

+ Inheritance

	+ [Single Inheritance](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Inheritance/SingleInheritance.java)

	+ [Multi-level Inheritance](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Inheritance/MultilevelInheritance.java)

	+ [Hierarchical Inheritance](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Inheritance/HierarchicalInheritance.java)

	+ [Multiple Inheritance](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Inheritance/MultipleInheritance.java)

+ Class 

	+ [Abstract Class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/AbstractClass.java)

	+ [Anonymous Class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/AnonymousClass.java)

	+ [Assigning one object to other](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/AssigningOneObjectToOther.java)

	+ [Final class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/FinalClass.java)

	+ [Local class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/LocalClass.java)

	+ [Nested Class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/NestedClass.java)

	+ [Private Access Specifier](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/PrivateAccessSpecifier.java)

	+ [Simple Class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/SimpleClass.java)

	+ [Singleton Class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/SingletonClass.java)

+ Generics 

	* [Generic Class Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Generics/GenericClassExample.java)

	* [Generic Method Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Generics/GenericMethodExample.java)

+ Polymorphism 

	+ [Constructor Overloading](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Polymorphism/ConstructorOverLoading.java)

	+ [Method Overloading](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Polymorphism/MethodOverLoading.java)

+ Exception Handling 

	* [Simple Try Catch Example ](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/SimpleExceptionExample.java)

	* [Tru Catch Finally Mutliple Exception Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/MultipleException.java)

	+ [User Defined Exception Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/UserDefinedException.java)

	* [Exmple of subclass Exception](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/SubClassException.java)

	+ [Throw Exception](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/ThrowException.java)

	+ [Throws Exception](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/ThrowsException.java)

+ Multi-Threading in java 

	* [Main Thread Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/MainThreadExample.java)

	* [Example of creating Thread with Thread Class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/ThreadMethodsExample.java)

	* [Example of creating Thread with Runnable interface](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/RunnableThreadExample.java)

	* [Synchronization Threads Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/SynchronizationThreadsExample.java)

	* [Multiple Threads](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/MultipleThreads.java)

	* [Multiple Threads With Join Method](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/MultipleThreadsWithJoin.java)

	* [Example Volatile Program](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/VolatileExample.java)

	* [Example of Inter Thread communication in Threads](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/InterThreadCommunication.java)

	* [Example of DeadLock in Threads](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/DeadLockInThreads.java)

	* [Example of Interrupting Thread Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/InterruptingThreadExample.java)

	* [Transient Keyword Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/TransientExample.java)

+ Object Cloning 

	* [Shallow copy Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ObjectCloning/ShallowCopyExample.java)


	* [deep copy Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/DeepCopyExample.java)

	
+ packages


	* [Package Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Packages/myPackage)

+ Collections 

	+ ArrayList 

		* [Array List Methods Example 1](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Collections/List/ListExample.java)

		* [Array List Example 2](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Collections/List/ArrayListExample.java)
	
	+ Iterator 

		* [Iterator](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Collections/Iterators/IteratorExample.java)

		* [ListIterator](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Collections/Iterators/ListIteratorExample.java)

	+ Vector

		+ [Vector Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/VectorExample.java)

	+ Stack

		*  [Stack Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Collections/Stack/StackExample.java)

	+ Queue 

		* [Queue Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Collections/Queue/QueueExample.java)


	+ Priority Queue 

		* [Priority Queue Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Collections/Queue/PriorityQueueExample.java)

	+ Map

		* [HashMap Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Collections/Map/HashMapExample.java)

	+ Hash Table

		* [Hash Table](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Collections/Map/HashTableExample.java)

	* Set 

		* [Hash Set](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Collections/Set/HashSetExample.java)

### History of Java

* Java was developed by `James Gosling`   and team in `1991 -1993` as a `system independent language`.

* The Java programming language is a general-purpose programming language that is based on the OOPs concept.

* Java is a platform-independent and robust programming language. 

* The principle followed by Java is `WORA` that says `Write Once, Run Anywhere`. 

* Core java involves basic concepts in java  and it is a part of java SE.


### Java - System Independent Language

* when the `source code of a java program` is `compiled`, it is converted into the `byte code` file for a virtual machine.

* the compiled program in byte code can be run on different computers having different operating systems with the help of `JVM(java virtual machines)`.

* JVM will `interprets` the `byte code` into `machine specific instructions` and runs the program.

### Java - Compiled and Interpreted Language

* Java uses both interpretation and compilation process and making it a two - stage programming system.

* first, the java compiler generated a class file(.class)  from its source file(.java file).

* this class file with .class extension contains the bytecode that are platform independent for JVM

* java interpreter in jvm will convert the byte code into machine language code according to its platform. 

* then , JVM provide the environment and it will load and run the program in the system.

* in `java byte code`, the libraries will not be added into the file to make it executable. so compiled code are small in size.

* JAVA API will used to invoke the needed libraries while running on the virtual machine.

+ java byte code cannot call the operating system libraries directly (example like I/O  operations).

+ Resources required to run the bytecode are made available by the `Java Virtual Machine`, which `calls the processor` to `allocate the required resources`.

### DATA TYPES in java

* `primitive data type`: (build in types) (java doesn't support unsigned numbers )

    * byte -  8 bit 

    * short - 2 bytes

    * int -   4 bytes

    * long -  8 bytes

    * boolean - 1 bit

    * float - 4 bytes

    * double - 8 bytes

    * char - 2 bytes

* `non-primitive types`:

    * these ar the class and interfaces types that are defined by the user.

### Java Wrapper Class

* Wrapper classes are classes that wraps primitive data types.

* They are very helpful in creating Collections as per our need where object is required.


| Primitive Data type      | Wrapper Class |
| -----------------------  | --------------|
| char                     | Character     |
| byte                	   | Byte          |
| short 				   | Short		   |
| int                      | Integer       |
| long                     | Long          |
| float                    | Float         | 
| double                   | Double        |
| boolean                  | Boolean       |


```
int i = 10;

// Boxing,wrapping
Integer i2 = Integer.valueOf(15);

// this is also boxing where compiler will convert this 12 to Integer.valueOf(12);
// Autoboxing
Integer i3 = 12;

// unboxing, unwrapping
int j = i2.intValue();

int k = i3; // auto unboxing 
```

### type casting  or type conversion 

* to convert the data from one type to another type in the program 


* order of type casting is as follows 

byte -> short -> int,char -> long -> float -> double 

* Conversion from lower order to higher order

```
public class Main {

	/*
		** output **
		18
	*/

	public static void main(String[] args)
	{
		byte a = 8;
		short b = 10;
		int c=a+b; // type casting 
		System.out.println(c);
	}
}
```

* when we trying to caste a value from higher order to lower order we need to specifiy like this

* type variable = (new_type) variable

```
double d=6.8;
int value=(int)d; // type casting

// value = 6
```

### Type conversion in java with wrapper classes

* To convert from one data type to another

```
String num = "123";
int a = Integer.parseInt(num);
```

### Autoboxing in java 

* Each primitive data type also has a full Java class implementation that can wrap it. For instance, the Integer class can wrap an int.

* There is sometimes a need to convert from the primitive type to its object wrapper (e.g., using them with generics).

* Java can perform this conversion for us automatically, a process called Autoboxing:

```
Character c = 'c';

Integer i = 1;
```

### Static variable

* generally when a object of a class is created a copy of it is stored.

* if the variable is declared static then there will be only one variable copy in the memory. 

### Static import
*  If we use static import of the Math class, there is no need to use class reference with every method. 
```
import static java.lang.Math.*;
public class Hello{
    public static void main(String[] args)
    {
        // we can call the methods simply by their name without the package name
        System.out.println(sqrt(100));
    }
}
```

### Final Keyword

* The value of a variable declared `final` cannot be changed in the program.

* It makes the varable as a `constant`

```
final double PI = 3.14159;
```

### Chain of Assignment

```
int a,b,c,d;
a=b=c=10;
```

### Call by value and Call by Reference in Java 

+ [clear Article link](https://www.geeksforgeeks.org/g-fact-31-java-is-strictly-pass-by-value/).

+ Java is Strictly Pass by Value for primitive data types of java 

+ But in java, All non-primitives (or objects of any class) are always references.

+  So it gets tricky when we pass object references to methods. 

+ Java creates a copy of references and pass it to method, but they still point to same memory reference. 

+ Mean if set some other reference to object passed inside method, the object from calling method as well its reference will remain unaffected. 

+ But if we change the member variables of an object that it is passed, it will be changed 


### Arrays in Java 

* An array in Java is a group of like-typed variables referred to by a common name.

* In Java, all arrays are dynamically allocated

* Arrays are stored in consecutive memory locations.

* Since arrays are objects in Java, we can find their length using the object property length.

* The size of an array must be specified by int

```
int intArray[];   //declaring array
intArray = new int[10];  //declaring array

// it can be also done in a single line 

int[] intArray = new int[20]; // combining both statements in one

```

### Array Literal

* In a situation where the size of the array and variables of the array are already known, array literals can be used. 

* The length of this array determines the length of the created array.

* There is no need to write the new int[] part in the latest versions of Java.

[Array Literal Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/ForEachLoop.java)

```
// Declaring array literal
 int[] intArray = new int[]{ 1,2,3,4,5,6,7,8,9,10 }; 
 
``` 

### Multi-Dimensional Array in java 

	* Arrays will have internal arrays in each index;
	
```
int array[][]= {
	    {1,1,1,1},
	    {2,2,2,2},
	    {3,3,3,3},
	    {4,4,4,4}
	};
```

### Dynamic Memory Change in Array

+ The number of elements(size) of array may change during the execution of the program.

+ you can dynamically change the number of elements by dynamically retaining the array name.

+ [Dynamic Memory Change Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/DynamicArraySizeChange.java)

### Array Methods in java 

+ [Array Methods Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/ArrayMethodsExample.java)


### Strings in Java

* string is basically an object that represents sequence of char values. An array of characters works same as Java string.

* [String Manipulation in java code](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Strings/StringManipulation.java)


### String Storage

* They are three classes to handle string  and they are available in java.lang package.

	* `class String` - stored in `string constant pool and heap`, not mutable, thread safe and fast.

	* `class StringBuffer` - stored in `Heap` , mutable,thread safe and slow

	* `class StringBuilder` - stored in `Heap`, mutable, Not thread safe and fast

* The objects of class String have aspcial storage facility,which is not available to other two classes.

* normally. The memory allocated to java program is divided into two segments 

	* Stack - The program is stored on the stack.

	* Heap - The variables are stored in heap. In heap, there is memory segment called `String constant pool`. 

	* String constant pool has only unique String values. 

	* If you declare another string with same value. The reference will be already in pool . so it will be referred instead of creating a new instant


```
// String defined like this are stored in String constant pool
String strx = "abcd";

// Strings defined using new operator are stored on heap memory

String strz = new String("abcd")
```

### Difference between == and equals in String 

* == comparess the references, i.e two references point to the same object 

* equals() method compares the content of two strings 

```
String str1 = "Delhi";
String str2 = "Delhi";
String str3 = new String("Delhi");

str1 == str2  // true ( as both variable be pointing to same reference in the string constant pool)

str2 == str3 // false ( as both variable be pointing to difference references in different location)

str1.equals(str2) // true ( as it will compare the contents of two strings)
```

### Interface 

* Interface is a type of class that defines only absract methods 

* An interface is a completely "abstract class" that is used to group related methods with empty bodies.

* To access the interface methods, the interface must be "implemented" (kinda like inherited) by another class with the implements keyword (instead of extends). The body of the interface method is provided by the "implement" class:

* The methods declared in interface are implicitly public a bstract methods.

* The variables in interface must be initialized either compile time error will be thrown.

* They can be top level interface, nested interface and generic interface.

* Interface attributes are by default public, static and final

* we have to define all the methods inside interface else the class will be treated as an abstract class.

* we can use inheritance in interface 

```
interface A {}
interface B {}

interface C extends A,B{}

```

### Default methods in interfaces 

* The java SE8 enhancement of interfaces allows the interfaces to have full definitions of `default` and static methods.

* Default methods cannot be declared as final and gives compilation error.

```
public interface InterfaceA{
	default void display(){
		System.out.println("Hello");
	}
}
```

### When to use Interface 

* To achieve security - hide certain details and only show the important details of an object (interface).

*  Java does not support "multiple inheritance" (a class can only inherit from one superclass). However, it can be achieved with interfaces, because the class can implement multiple interfaces. Note: To implement multiple interfaces, separate them with a comma.


### Arrow Functions 

* Arrow Functions or lambda expressions can be used to implement the only abstract function and therefore implement functional interfaces.



### Exception Handling 

* Exception Handling is a mechanism to `handle runtime errors` such as ClassNotFoundException, IOException, SQLException, RemoteException, etc.

* An Exception is an undesirable event that may occur during the execution of the program and may lead to termination of the program if it is not handled properly.

* Advantage of Exception Handling, 

	* To maintain the normal working flow of application.
	
	* Provision to Complete Program Execution

	* Easy Identification of Program Code and Error-Handling Code

	* Propagation of Errors

	* Meaningful Error Reporting
	
	* Identifying Error Types

* [Simple Try Catch Example ](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/SimpleExceptionExample.java)

* All exception and error types are subclasses of `class Throwable`, which is the base class of the hierarchy.

* One branch is headed by `Exception`. This class is used for `exceptional conditions that user programs should catch`.

* Another branch, `Error` is used by the Java run-time system(JVM) to `indicate errors having to do with the run-time environment itself(JRE)`. StackOverflowError is an example of such an error.

<p align="center">
	<img src="https://media.geeksforgeeks.org/wp-content/uploads/Exception-in-java1.png" alt="Throwable Class Heirarchy"/>
</p>

### Types of Exception 

<p align="center">
	<img src="https://media.geeksforgeeks.org/wp-content/uploads/20220120111809/Group21-660x330.jpg" alt="Throwable Class Heirarchy"/>
</p>

* Built-in Exceptions

	* Built-in exceptions are the exceptions that are available in Java libraries. These exceptions are suitable to explain certain error situations.

	* It is of two types 

		* Checked Exception

			* Checked exceptions are called `compile-time exceptions` because these exceptions are `checked at compile-time` by `the compiler`.

		* Unchecked Exception 

			* The unchecked exceptions are just opposite to the checked exceptions. The compiler will not check these exceptions at compile time. 
			
			* In simple words, if a program throws an unchecked exception, and even if we didn’t handle or declare it, the program would not give a compilation error.

* User-Defined Exceptions

	* Sometimes, the built-in exceptions in Java are not able to describe a certain situation. 
	
	* In such cases, users can also create exceptions, which are called ‘user-defined Exceptions’. 

	+ [User Defined Exception Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/UserDefinedException.java)

### Try-Catch-Finally Exception 

* At first, the code inside the try block will be executed. If any exception is occured,it is mapped to the correct Catch Block.

* Finally will be executed once try and catch block is executed.

* [Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/MultipleException.java)

```
try {
    // block of code to monitor for errors
    // the code you think can raise an exception
} catch (ExceptionType1 exOb) {
    // exception handler for ExceptionType1
} catch (ExceptionType2 exOb) {
    // exception handler for ExceptionType2
}
// optional
finally {  // block of code to be executed after try and catch block ends 
}
```

### Throwable Class 

* class Throwable is super class to all the error and exeption class. 

### Catching Subclass Exception

* If super class method does not have any exception declaration, and child class overrides the method with an exception will cause an run time exception 

* [Exmple of subclass Exception](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/SubClassException.java)


### Throw keyword

* The throw keyword in Java is used to explicitly throw an exception from a method or any block of code.

* We can throw either checked or unchecked exception. 

* The throw keyword is mainly used to throw custom exceptions. 

```
//syntax
throw Instance
Example:
throw new ArithmeticException("/ by zero");
```

+ [Throw Exception](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/ThrowException.java)

### Throws Keyword 

+ throws is a keyword in Java which is used in the signature of method to indicate that this method might throw one of the listed type exceptions.

* The caller to these methods has to handle the exception using a try-catch block. 

+ throws keyword is required only for checked exception and usage of throws keyword for unchecked exception is meaningless.

+ throws keyword is required only to convince compiler and usage of throws keyword does not prevent abnormal termination of program.

+ By the help of throws keyword we can provide information to the caller of the method about the exception.

+ [Throws Exception](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/ThrowsException.java)

### Generics

* Generics `means parameterized types`.

+ The idea is to allow type (Integer, String, … etc., and user-defined types) to be a parameter to methods, classes, and interfaces.

+  Using Generics, it is possible to create classes that work with different data types

+ The `Object` is the `superclass of all other classes`, and Object reference can refer to any object.

+ These features lack type safety. Generics `adds that type safety` feature.

+ The compiler takes care of the type of safety which enables programmers to code easily since they do not have to perform long, individual type castings.

+ The `Type naming conventions`  in java Generics

	+  The common type parameters are as follows:

		+ T – Type
		+ E – Element
		+ K – Key
		+ N – Number
		+ V – Value

+ Advantage of using generics is that `code reusability` and `Type safety`.

+ Type of Generics in java 

	+ Generic Methods 
		
		* Generic Java method takes a parameter and returns some value after performing a task. It is exactly like a normal function, however, a generic method has type parameters that are cited by actual type. 

		* [Generic Method Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Generics/GenericMethodExample.java)

	+ Generic Class 
		
		* A generic class is implemented exactly like a non-generic class. The only difference is that it contains a type parameter section. There can be more than one type of parameter, separated by a comma.

		* [Generic Class Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Generics/GenericClassExample.java)

### Multi Threading in java 

* Multi Threading is inbuilt in java and CPU capacity utilization may be improved by having multiple thread that concurrently execute different parts of the program.

* Multithreading is a `Thread-based multitasking` is a `lightweight process` and occupies the same address space. Hence, while switching cost of communication will be very less.

* when we run a program in java , `one thread` is automatically created and it executes the main method. This thread is called `Main Thread`.

* Main Thread can also be controlled through it's reference and by using `static method Thread.currentThread()`.

* Advantages are Efficient use of processors,performance and Better performance.

* Disadvantages are DeadLock,unexpected results and need an over head to handle maintain threads and scheduling.

* [Main Thread Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/MainThreadExample.java)

* Two Ways to Implement Multithreading

	* using  Thread class 

		* [Example of creating Thread with Thread Class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/ThreadMethodsExample.java)

		* Highest Thread priority is 10 and minimum priority is 1 and mid priority is 5.

		* Thread with max priority will be executed first.
	* using  Runnable Interface

		* [Example of creating Thread with Thread Class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/RunnableThreadExample.java)

### Life Cycle of Threads 

* A new Object of thread class is created.

* start() method makes thread object alive 

* Thread object executes its run() method

* Thread may undergo sleep() and can come back and resume()

* Thread object dies after run() is over

<p align="center">
	<img src="https://media.geeksforgeeks.org/wp-content/uploads/20210421114547/lifecycleofthread.jpg" alt="lifecyle of threads"/>
</p>

### synchroniztation in Threads 

* Synchronization in Java is the capability to control the access of multiple threads to any shared resource.

* Java Synchronization is better option where we want to allow only one thread to access the shared resource.

* The synchronization is mainly used to

   * To prevent thread interference.
   
   * To prevent consistency problem.

* [Synchronization code Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/SynchronizationThreadsExample.java)



### DeadLock in Threads 

* synchronized keyword is used to make the class or method thread-safe which means only one thread can have lock of synchronized method and use it, other threads have to wait till the lock releases and anyone of them acquire that lock. 

* This may cause one thread to wait for the other thread release the use of resources 

* But some times both thread will be needing two resources, but both thread will be holding one resources making both the threads to wait. This is called `DeadLock`.

* It occurs dues to improper `synchronized threads` having a shared target data source.

* Deadlock condition is a complex condition which occurs only in case of multiple threads.

* Deadlock condition can break our code at run time and can destroy business logic.


<p align="center">
	<img src="https://media.geeksforgeeks.org/wp-content/uploads/22-2.png" alt="DeadLock Example">
</p>

### ways to avoid dead lock 

* Avoid nested locks 

* Avoid Unnecessary Locks 

* Handle  Thread join Correctly - Thread.join with maximum time you think the execution will take.

* [Example of DeadLock in Threads](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/DeadLockInThreads.java)


### yield() method in threads

* The yield() basically means that the thread is not doing anything particularly important and if any other threads or processes need to be run, they should run. Otherwise, the current thread will continue to run.

* if one thread is going to run for 5 hours and other thread will complete in 5 minutes. we can make the minimal thread to run first and the long thread next.

<p align="center">
<img src="https://media.geeksforgeeks.org/wp-content/uploads/50-1.png" alt="yield example">
</p>

### InterThread Communication 

* Inter-thread communication or Co-operation is all about allowing synchronized threads to communicate with each other.

* [Example of Inter Thread communication in Threads](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/InterThreadCommunication.java)

* Cooperation (Inter-thread communication) is a mechanism in which a thread is paused running in its critical section and another thread is allowed to enter (or lock) in the same critical section to be executed.It is implemented by following methods of Object class:

	* wait()

		* The wait() method causes current thread to release the lock and wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed.

		* It must be called from synchronized method
	
	* notify()

		* The notify() method wakes up a single thread that is waiting on this object's monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation.

	* notifyAll()

		* Wakes up all threads that are waiting on this object's monitor

<p align="center">
	<img src="https://media.geeksforgeeks.org/wp-content/uploads/20211216134207/imagereedit3.jpg" alt="DeadLock Example">
</p>


### volatile keyword 

* The value of the variable that is declared volatile may be changed by other parts of the program.

* Normally threaed create copies of the initial values of varaibles in a cache memory  and process the values and stores the value in cache,which is not visible to other threads.

*  volatile keyword gives solution to this problem by intimating the JVM that all read and write processes on tha variable be shared with all other threads as a common variable.

* It is also used to make classes thread safe. 

* It means that multiple threads can use a method and instance of the classes at the same time without any problem.

* [Example Volatile Program](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/VolatileExample.java)

### Transient keyword 

* In Java, Serialization is used to convert an object into a stream of the byte. 

* The byte stream consists of the data of the instance as well as the type of data stored in that instance. 

* Deserialization performs exactly opposite operation. It converts the byte sequence into original object data. 

* `During the serialization`, when `we do not want an object to be serialized` we can use a `transient keyword`.

* transient can be used in data members of the class in order to avoid serialization.

* Example: if our object store username and password, they don't have to be serialized inorder to ensure integrity. so we use transient here , jvm will replace these values of member variables with default value of object.

* [Example Volatile Program](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/TransientExample.java)

### java object cloning 

* The object cloning is a way to create exact copy of an object. The clone() method of Object class is used to clone an object.

*  It creates a new instance of the class of the current object and initializes all its fields with exactly the contents of the corresponding fields of this object.

* shallow copy 

	* Shallow copy is the method of copying an object and is followed by default in cloning.

	* In this method, the fields of an old object X are copied to the new object Y.

	* Therefore, any changes made in referenced objects in object X or Y will be reflected in other objects.

	* [Shallow copy Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ObjectCloning/ShallowCopyExample.java)

* deep copy 

	* If we want to create a deep copy of object X and place it in a new object Y then a new copy of any referenced objects fields are created and these references are placed in object Y.

	* This means any changes made in referenced object fields in object X or Y will be reflected only in that object and not in the other.

	* [deep copy Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/DeepCopyExample.java)



### Packages in java 

* Package in Java is a mechanism to encapsulate a group of classes, sub packages and interfaces. 

* packages are used for 

	* preventing naming conflicts.

	* making searching/locating and easy access of classes, interfaces etc.

	* providing controlled access through access specifier 

	* protected and default have package level access control.

	* Packages can be considered as data encapsulation (or data-hiding).

* packages are of two types 

	* user defined packages

	* Built in packages 

* Every class is part of some package.

* If no package is specified, the classes in the file goes into a special unnamed package (the same unnamed package for all files).

* [Package Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Packages/myPackage)

```
// package
myPackage 
	// class containing main function
	- Main.java 
	// sub-package
	- Shapes 

		- Square.java 

		- Rectangle.java 

// To perform compilation on myPackage Main.java 
// from parent directory of myPackage
$ javac myPackage/Main.java 

$ java myPackage/Main 
```


### Collections in Java 

* The collection framwork has been designed to store reference types and not primitive types.

* The purpose of Collection Framewordk

	* Uniformity of treatments for collections of different types.

	* High performance, increases program speed and quality as the implementation of this collection is targetted to best implementation measures.

	* Ease of application in real-world problems

### Hierarchy of the Collection Framework

<p align="center">
	<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20220526152255/Collections-in-Java1.png" alt="Hierarchy of colllection framework">
</p>


| Interface     | Implementation by Classes |
| --------------| --------------------------|
| Set           | HashSet, LinkedHashSet, EnumSet     |
| SortedSet     | TreeSet          |
| List          | Vector, Stack, ArrayList, LinkedList		   |
| Queue         | PriorityQueue, LinkedList       |
| Map           | HashMap, Hashtable, LinkedHashMap, IdentityHashMap,WeakHashMap          |
| SortedMap     | TreeMap         | 

### Code Samples for Collections 

### Iterator 

* Iterators are used to access the elements of aa colleciton one at a time.

* Almost all collections suppport iterators except the maps thar are not considered as collections.

* [Iterator](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Collections/Iterators/IteratorExample.java)

	* It can traverse the list only in forward direction

* [ListIterator](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Collections/Iterators/ListIteratorExample.java)

	* It can traverse the list in both directirons

### List - interface

* The List interface in Java provides a way to store the ordered collection. 

* It is a child interface of Collection.

* Since List is an interface, objects cannot be created of the type list.

* We always need a class that implements this List in order to create an object.

```
	List<Obj> list = new ArrayList<Obj> (); 
```

*  List is an `interface`, implemented by the `ArrayList class`, pre-defined in the java.util package. 

### ArrayList 

* The ArrayList class is a resizable array, which can be found in the java.util package.

* The difference between a built-in array and an ArrayList in Java, is that the size of an array cannot be modified (if you want to add or remove elements to/from an array, you have to create a new one).

*  While elements can be added and removed from an ArrayList whenever you want.

* ArrayList can not be used for primitive types, like int, char, etc. We need a wrapper class for such cases.

* [Array List Methods Example 1](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Collections/List/ListExample.java)

* [Array List Example 2](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Collections/List/ArrayListExample.java)

### Priority Queue 

* A PriorityQueue is used when the objects are supposed to be processed based on the priority.

* It is known that a Queue follows the First-In-First-Out algorithm, but sometimes the elements of the queue are needed to be processed according to the priority, that’s when the PriorityQueue comes into play.

* In the below priority queue, an element with a maximum ASCII value will have the highest priority.

### Map 

* Maps are perfect to use for key-value association mapping such as dictionaries. 

* The maps are used to perform lookups by keys or when someone wants to retrieve and update elements by keys

* A Map cannot contain duplicate keys and each key can map to at most one value. 

* Some implementations allow null key and null values like the HashMap and LinkedHashMap, but some do not like the TreeMap.

### Hash Table 

* The Hashtable class implements a hash table, which maps keys to values. 

* Any non-null object can be used as a key or as a value. 

* To successfully store and retrieve objects from a hashtable, the objects used as keys must implement the hashCode method and the equals method.  


### Difference between hashmap and hashtable 

* HashMap is non-synchronized. It is not thread-safe and can’t be shared between many threads without proper synchronization code whereas Hashtable is synchronized. It is thread-safe and can be shared with many threads.

* HashMap allows one null key and multiple null values whereas Hashtable doesn’t allow any null key or value.

* HashMap is generally preferred over HashTable if thread synchronization is not needed.

*  In order to successfully store and retrieve objects from a HashTable, the objects used as keys must implement the hashCode method and the equals method. 

* Since null is not an object, it can’t implement these methods. HashMap is an advanced version and improvement on the Hashtable. HashMap was created later. 

* unconvered - LinkedList , deque, LinkedHashSet,TreeSet,EnumSet,TreeMap,LinkedHashMap