# Java Notes 
    This repo contains source code of java concepts and oops.

### Codes in this repo

+ Basic Hello World 

	+ [Simple Hello World Program](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Basics/HelloWorld.java)

	+ [Assertion Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Basics/AssertionExample.java)


+ Command Line Arguments

	+ [Command Line Arguments Program](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Basics/CommandLineArguments.java)

	+ [Command Line Arguments sum Program](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Basics/CommandLineArgumentsSum.java)

+ Sorting Alogrithms

	+ [Sorting Alogrithms ](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/SortingAlgorithms/SortData.java)


+ Methods 

	+ [Final Methods](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Basics/FinalMethods.java)

	+ [Method Arguments](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Basics/MethodArguments.java)

	+ [To String Override](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Basics/ToStringOverride.java)

	+ [Arrow Functions](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Basics/ArrowFunctions.java)



+ Searching Algorithms

	+ [Linear Search](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Searching-Algorithms/LinearSearch.java)

	+ [Binary Search](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Searching-Algorithms/BinarySearch.java)

	+ [Recursive Binary Search](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Searching-Algorithms/RecursiveBinarySearch.java)

+ String
	
	+ [String Manipulation in java](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Strings/StringManipulation.java)

	+ [ComapareTo Example in java](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Strings/CompareToExample.java)

	+ [String Buffer Example in java](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Strings/OtherStringClassManipulation.java)




+ Arrays

	+ [For Each with Array Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/ForEachLoop.java)

	+ [Arrays class In Built Methods Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/ArrayMethodsExample.java)

	+ [Transpose of Matrix](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/TransposeOfMatrix.java)

	+ [Matrix Multiplication](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/MatrixMultiplication.java)

	+ [Vector Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/VectorExample.java)

	+ [Dynamic Array Size change]((https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/DynamicArraySizeChange.java))

+ Inheritance

	+ [Single Inheritance](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Inheritance/SingleInheritance.java)

	+ [Multi-level Inheritance](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Inheritance/MultilevelInheritance.java)

	+ [Hierarchical Inheritance](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Inheritance/HierarchicalInheritance.java)

	+ [Multiple Inheritance](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Inheritance/MultipleInheritance.java)

+ Class 

	+ [Abstract Class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/AbstractClass.java)

	+ [Anonymous Class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/AnonymousClass.java)

	+ [Assigning one object to other](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/AssigningOneObjectToOther.java)

	+ [Final class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/FinalClass.java)

	+ [Local class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/LocalClass.java)

	+ [Nested Class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/NestedClass.java)

	+ [Private Access Specifier](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/PrivateAccessSpecifier.java)

	+ [Simple Class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/SimpleClass.java)

	+ [Singleton Class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Class/SingletonClass.java)

+ Generics 

	* [Generic Class Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Generics/GenericClassExample.java)

	* [Generic Method Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Generics/GenericMethodExample.java)

+ Polymorphism 

	+ [Constructor Overloading](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Polymorphism/ConstructorOverLoading.java)

	+ [Method Overloading](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Polymorphism/MethodOverLoading.java)

+ Exception Handling 

	* [Simple Try Catch Example ](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/SimpleExceptionExample.java)

	* [Tru Catch Finally Mutliple Exception Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/MultipleException.java)

	+ [User Defined Exception Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/UserDefinedException.java)

	* [Exmple of subclass Exception](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/SubClassException.java)

	+ [Throw Exception](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/ThrowException.java)

	+ [Throws Exception](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/ThrowsException.java)

+ Multi-Threading in java 

	* [Main Thread Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/MainThreadExample.java)

	* [Example of creating Thread with Thread Class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/ThreadMethodsExample.java)


### History of Java

* Java was developed by `James Gosling`   and team in `1991 -1993` as a `system independent language`.

* The Java programming language is a general-purpose programming language that is based on the OOPs concept.

* Java is a platform-independent and robust programming language. 

* The principle followed by Java is `WORA` that says `Write Once, Run Anywhere`. 

* Core java involves basic concepts in java  and it is a part of java SE.


### Java - System Independent Language

* when the `source code of a java program` is `compiled`, it is converted into the `byte code` file for a virtual machine.

* the compiled program in byte code can be run on different computers having different operating systems with the help of `JVM(java virtual machines)`.

* JVM will `interprets` the `byte code` into `machine specific instructions` and runs the program.

### Java - Compiled and Interpreted Language

* Java uses both interpretation and compilation process and making it a two - stage programming system.

* first, the java compiler generated a class file(.class)  from its source file(.java file).

* this class file with .class extension contains the bytecode that are platform independent for JVM

* java interpreter in jvm will convert the byte code into machine language code according to its platform. 

* then , JVM provide the environment and it will load and run the program in the system.

* in `java byte code`, the libraries will not be added into the file to make it executable. so compiled code are small in size.

* JAVA API will used to invoke the needed libraries while running on the virtual machine.

+ java byte code cannot call the operating system libraries directly (example like I/O  operations).

+ Resources required to run the bytecode are made available by the `Java Virtual Machine`, which `calls the processor` to `allocate the required resources`.

### DATA TYPES in java

* `primitive data type`: (build in types) (java doesn't support unsigned numbers )

    * byte -  8 bit 

    * short - 2 bytes

    * int -   4 bytes

    * long -  8 bytes

    * boolean - 1 bit

    * float - 4 bytes

    * double - 8 bytes

    * char - 2 bytes

* `non-primitive types`:

    * these ar the class and interfaces types that are defined by the user.

### type casting  or type conversion 

* to convert the data from one type to another type in the program 


* order of type casting is as follows 

byte -> short -> int,char -> long -> float -> double 

* Conversion from lower order to higher order

```
public class Main {

	/*
		** output **
		18
	*/

	public static void main(String[] args)
	{
		byte a = 8;
		short b = 10;
		int c=a+b; // type casting 
		System.out.println(c);
	}
}
```

* when we trying to caste a value from higher order to lower order we need to specifiy like this

* type variable = (new_type) variable

```
double d=6.8;
int value=(int)d; // type casting

// value = 6
```

### Autoboxing in java 

* Each primitive data type also has a full Java class implementation that can wrap it. For instance, the Integer class can wrap an int.

* There is sometimes a need to convert from the primitive type to its object wrapper (e.g., using them with generics).

* Java can perform this conversion for us automatically, a process called Autoboxing:

```
Character c = 'c';

Integer i = 1;
```

### Static variable

* generally when a object of a class is created a copy of it is stored.

* if the variable is declared static then there will be only one variable copy in the memory. 

### Static import
*  If we use static import of the Math class, there is no need to use class reference with every method. 
```
import static java.lang.Math.*;
public class Hello{
    public static void main(String[] args)
    {
        // we can call the methods simply by their name without the package name
        System.out.println(sqrt(100));
    }
}
```

### Final Keyword

* The value of a variable declared `final` cannot be changed in the program.

* It makes the varable as a `constant`

```
final double PI = 3.14159;
```

### Chain of Assignment

```
int a,b,c,d;
a=b=c=10;
```

### Call by value and Call by Reference in Java 

+ [clear Article link](https://www.geeksforgeeks.org/g-fact-31-java-is-strictly-pass-by-value/).

+ Java is Strictly Pass by Value for primitive data types of java 

+ But in java, All non-primitives (or objects of any class) are always references.

+  So it gets tricky when we pass object references to methods. 

+ Java creates a copy of references and pass it to method, but they still point to same memory reference. 

+ Mean if set some other reference to object passed inside method, the object from calling method as well its reference will remain unaffected. 

+ But if we change the member variables of an object that it is passed, it will be changed 


### Arrays in Java 

* An array in Java is a group of like-typed variables referred to by a common name.

* In Java, all arrays are dynamically allocated

* Arrays are stored in consecutive memory locations.

* Since arrays are objects in Java, we can find their length using the object property length.

* The size of an array must be specified by int

```
int intArray[];   //declaring array
intArray = new int[10];  //declaring array

// it can be also done in a single line 

int[] intArray = new int[20]; // combining both statements in one

```

### Array Literal

* In a situation where the size of the array and variables of the array are already known, array literals can be used. 

* The length of this array determines the length of the created array.

* There is no need to write the new int[] part in the latest versions of Java.

[Array Literal Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/ForEachLoop.java)

```
// Declaring array literal
 int[] intArray = new int[]{ 1,2,3,4,5,6,7,8,9,10 }; 
 
``` 

### Multi-Dimensional Array in java 

	* Arrays will have internal arrays in each index;
	
```
int array[][]= {
	    {1,1,1,1},
	    {2,2,2,2},
	    {3,3,3,3},
	    {4,4,4,4}
	};
```

### Dynamic Memory Change in Array

+ The number of elements(size) of array may change during the execution of the program.

+ you can dynamically change the number of elements by dynamically retaining the array name.

+ [Dynamic Memory Change Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/DynamicArraySizeChange.java)

### Array Methods in java 

+ [Array Methods Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Arrays/ArrayMethodsExample.java)


### Strings in Java

* string is basically an object that represents sequence of char values. An array of characters works same as Java string.

* [String Manipulation in java code](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Strings/StringManipulation.java)


### String Storage

* They are three classes to handle string  and they are available in java.lang package.

	* `class String` - stored in `string constant pool and heap`, not mutable, thread safe and fast.

	* `class StringBuffer` - stored in `Heap` , mutable,thread safe and slow

	* `class StringBuilder` - stored in `Heap`, mutable, Not thread safe and fast

* The objects of class String have aspcial storage facility,which is not available to other two classes.

* normally. The memory allocated to java program is divided into two segments 

	* Stack - The program is stored on the stack.

	* Heap - The variables are stored in heap. In heap, there is memory segment called `String constant pool`. 

	* String constant pool has only unique String values. 

	* If you declare another string with same value. The reference will be already in pool . so it will be referred instead of creating a new instant


```
// String defined like this are stored in String constant pool
String strx = "abcd";

// Strings defined using new operator are stored on heap memory

String strz = new String("abcd")
```

### Difference between == and equals in String 

* == comparess the references, i.e two references point to the same object 

* equals() method compares the content of two strings 

```
String str1 = "Delhi";
String str2 = "Delhi";
String str3 = new String("Delhi");

str1 == str2  // true ( as both variable be pointing to same reference in the string constant pool)

str2 == str3 // false ( as both variable be pointing to difference references in different location)

str1.equals(str2) // true ( as it will compare the contents of two strings)
```

### Interface 

* Interface is a type of class that defines only absract methods 

* An interface is a completely "abstract class" that is used to group related methods with empty bodies.

* To access the interface methods, the interface must be "implemented" (kinda like inherited) by another class with the implements keyword (instead of extends). The body of the interface method is provided by the "implement" class:

* The methods declared in interface are implicitly public a bstract methods.

* The variables in interface must be initialized either compile time error will be thrown.

* They can be top level interface, nested interface and generic interface.

* Interface attributes are by default public, static and final

* we have to define all the methods inside interface else the class will be treated as an abstract class.

* we can use inheritance in interface 

```
interface A {}
interface B {}

interface C extends A,B{}

```

### Default methods in interfaces 

* The java SE8 enhancement of interfaces allows the interfaces to have full definitions of `default` and static methods.

* Default methods cannot be declared as final and gives compilation error.

```
public interface InterfaceA{
	default void display(){
		System.out.println("Hello");
	}
}
```

### When to use Interface 

* To achieve security - hide certain details and only show the important details of an object (interface).

*  Java does not support "multiple inheritance" (a class can only inherit from one superclass). However, it can be achieved with interfaces, because the class can implement multiple interfaces. Note: To implement multiple interfaces, separate them with a comma.

### Exception Handling 

* Exception Handling is a mechanism to `handle runtime errors` such as ClassNotFoundException, IOException, SQLException, RemoteException, etc.

* An Exception is an undesirable event that may occur during the execution of the program and may lead to termination of the program if it is not handled properly.

* Advantage of Exception Handling, 

	* To maintain the normal working flow of application.
	
	* Provision to Complete Program Execution

	* Easy Identification of Program Code and Error-Handling Code

	* Propagation of Errors

	* Meaningful Error Reporting
	
	* Identifying Error Types

* [Simple Try Catch Example ](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/SimpleExceptionExample.java)

* All exception and error types are subclasses of `class Throwable`, which is the base class of the hierarchy.

* One branch is headed by `Exception`. This class is used for `exceptional conditions that user programs should catch`.

* Another branch, `Error` is used by the Java run-time system(JVM) to `indicate errors having to do with the run-time environment itself(JRE)`. StackOverflowError is an example of such an error.

<p align="center">
	<img src="https://media.geeksforgeeks.org/wp-content/uploads/Exception-in-java1.png" alt="Throwable Class Heirarchy"/>
</p>

### Types of Exception 

<p align="center">
	<img src="https://media.geeksforgeeks.org/wp-content/uploads/20220120111809/Group21-660x330.jpg" alt="Throwable Class Heirarchy"/>
</p>

* Built-in Exceptions

	* Built-in exceptions are the exceptions that are available in Java libraries. These exceptions are suitable to explain certain error situations.

	* It is of two types 

		* Checked Exception

			* Checked exceptions are called `compile-time exceptions` because these exceptions are `checked at compile-time` by `the compiler`.

		* Unchecked Exception 

			* The unchecked exceptions are just opposite to the checked exceptions. The compiler will not check these exceptions at compile time. 
			
			* In simple words, if a program throws an unchecked exception, and even if we didn’t handle or declare it, the program would not give a compilation error.

* User-Defined Exceptions

	* Sometimes, the built-in exceptions in Java are not able to describe a certain situation. 
	
	* In such cases, users can also create exceptions, which are called ‘user-defined Exceptions’. 

	+ [User Defined Exception Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/UserDefinedException.java)

### Try-Catch-Finally Exception 

* At first, the code inside the try block will be executed. If any exception is occured,it is mapped to the correct Catch Block.

* Finally will be executed once try and catch block is executed.

* [Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/MultipleException.java)

```
try {
    // block of code to monitor for errors
    // the code you think can raise an exception
} catch (ExceptionType1 exOb) {
    // exception handler for ExceptionType1
} catch (ExceptionType2 exOb) {
    // exception handler for ExceptionType2
}
// optional
finally {  // block of code to be executed after try and catch block ends 
}
```

### Throwable Class 

* class Throwable is super class to all the error and exeption class. 

### Catching Subclass Exception

* If super class method does not have any exception declaration, and child class overrides the method with an exception will cause an run time exception 

* [Exmple of subclass Exception](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/SubClassException.java)


### Throw keyword

* The throw keyword in Java is used to explicitly throw an exception from a method or any block of code.

* We can throw either checked or unchecked exception. 

* The throw keyword is mainly used to throw custom exceptions. 

```
//syntax
throw Instance
Example:
throw new ArithmeticException("/ by zero");
```

+ [Throw Exception](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/ThrowException.java)

### Throws Keyword 

+ throws is a keyword in Java which is used in the signature of method to indicate that this method might throw one of the listed type exceptions.

* The caller to these methods has to handle the exception using a try-catch block. 

+ throws keyword is required only for checked exception and usage of throws keyword for unchecked exception is meaningless.

+ throws keyword is required only to convince compiler and usage of throws keyword does not prevent abnormal termination of program.

+ By the help of throws keyword we can provide information to the caller of the method about the exception.

+ [Throws Exception](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/ExceptionHandling/ThrowsException.java)

### Generics

* Generics `means parameterized types`.

+ The idea is to allow type (Integer, String, … etc., and user-defined types) to be a parameter to methods, classes, and interfaces.

+  Using Generics, it is possible to create classes that work with different data types

+ The `Object` is the `superclass of all other classes`, and Object reference can refer to any object.

+ These features lack type safety. Generics `adds that type safety` feature.

+ The compiler takes care of the type of safety which enables programmers to code easily since they do not have to perform long, individual type castings.

+ The `Type naming conventions`  in java Generics

	+  The common type parameters are as follows:

		+ T – Type
		+ E – Element
		+ K – Key
		+ N – Number
		+ V – Value

+ Advantage of using generics is that `code reusability` and `Type safety`.

+ Type of Generics in java 

	+ Generic Methods 
		
		* Generic Java method takes a parameter and returns some value after performing a task. It is exactly like a normal function, however, a generic method has type parameters that are cited by actual type. 

		* [Generic Method Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Generics/GenericMethodExample.java)

	+ Generic Class 
		
		* A generic class is implemented exactly like a non-generic class. The only difference is that it contains a type parameter section. There can be more than one type of parameter, separated by a comma.

		* [Generic Class Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/Generics/GenericClassExample.java)

### Multi Threading in java 

* Multi Threading is inbuilt in java and CPU capacity utilization may be improved by having multiple thread that concurrently execute different parts of the program.

* Multithreading is a `Thread-based multitasking` is a `lightweight process` and occupies the same address space. Hence, while switching cost of communication will be very less.

* when we run a proram in java , `one thread` is automatically created and it executes the main method. This thread is called `Main Thread`.

* Main Thread can also be controlled through it's refernce and by using `static method Thread.currentThread()`.

* [Main Thread Example](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/MainThreadExample.java)

* Two Ways to Implement Multithreading

	* using  Thread class 

		*[Example of creating Thread with Thread Class](https://github.com/sakthivelan21/problem-solving/blob/main/Java-notes/MultiThreading/ThreadMethodsExample.java)

	* using  Runnable Interface


### Collections in Java 

### Packages in java 